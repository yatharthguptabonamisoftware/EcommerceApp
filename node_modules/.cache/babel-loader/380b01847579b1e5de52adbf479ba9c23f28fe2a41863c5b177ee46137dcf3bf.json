{"ast":null,"code":"import { getCurrentInstance, computed, watch, onMounted } from 'vue';\nimport { isFunction } from '@vue/shared';\nimport { isClient, isBoolean } from '@vueuse/core';\nimport '../../utils/index.mjs';\nimport { buildProp, definePropType } from '../../utils/vue/props.mjs';\nconst createModelToggleComposable = name => {\n  const useModelToggleProps2 = {\n    [name]: buildProp({\n      type: definePropType(Boolean),\n      default: null\n    }),\n    [`onUpdate:${name}`]: buildProp({\n      type: definePropType(Function)\n    })\n  };\n  const useModelToggleEmits2 = [`update:${name}`];\n  const useModelToggle2 = ({\n    indicator,\n    shouldHideWhenRouteChanges,\n    shouldProceed,\n    onShow,\n    onHide\n  }) => {\n    const instance = getCurrentInstance();\n    const props = instance.props;\n    const {\n      emit\n    } = instance;\n    const updateEventKey = `update:${name}`;\n    const hasUpdateHandler = computed(() => isFunction(props[`onUpdate:${name}`]));\n    const isModelBindingAbsent = computed(() => props[name] === null);\n    const doShow = () => {\n      if (indicator.value === true) {\n        return;\n      }\n      indicator.value = true;\n      if (isFunction(onShow)) {\n        onShow();\n      }\n    };\n    const doHide = () => {\n      if (indicator.value === false) {\n        return;\n      }\n      indicator.value = false;\n      if (isFunction(onHide)) {\n        onHide();\n      }\n    };\n    const show = () => {\n      if (props.disabled === true || isFunction(shouldProceed) && !shouldProceed()) return;\n      const shouldEmit = hasUpdateHandler.value && isClient;\n      if (shouldEmit) {\n        emit(updateEventKey, true);\n      }\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doShow();\n      }\n    };\n    const hide = () => {\n      if (props.disabled === true || !isClient) return;\n      const shouldEmit = hasUpdateHandler.value && isClient;\n      if (shouldEmit) {\n        emit(updateEventKey, false);\n      }\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doHide();\n      }\n    };\n    const onChange = val => {\n      if (!isBoolean(val)) return;\n      if (props.disabled && val) {\n        if (hasUpdateHandler.value) {\n          emit(updateEventKey, false);\n        }\n      } else if (indicator.value !== val) {\n        if (val) {\n          doShow();\n        } else {\n          doHide();\n        }\n      }\n    };\n    const toggle = () => {\n      if (indicator.value) {\n        hide();\n      } else {\n        show();\n      }\n    };\n    watch(() => props[name], onChange);\n    if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {\n      watch(() => ({\n        ...instance.proxy.$route\n      }), () => {\n        if (shouldHideWhenRouteChanges.value && indicator.value) {\n          hide();\n        }\n      });\n    }\n    onMounted(() => {\n      onChange(props[name]);\n    });\n    return {\n      hide,\n      show,\n      toggle\n    };\n  };\n  return {\n    useModelToggle: useModelToggle2,\n    useModelToggleProps: useModelToggleProps2,\n    useModelToggleEmits: useModelToggleEmits2\n  };\n};\nconst {\n  useModelToggle,\n  useModelToggleProps,\n  useModelToggleEmits\n} = createModelToggleComposable(\"modelValue\");\nexport { createModelToggleComposable, useModelToggle, useModelToggleEmits, useModelToggleProps };","map":{"version":3,"names":["createModelToggleComposable","name","useModelToggleProps2","buildProp","type","definePropType","Boolean","default","Function","useModelToggleEmits2","useModelToggle2","indicator","shouldHideWhenRouteChanges","shouldProceed","onShow","onHide","instance","getCurrentInstance","props","emit","updateEventKey","hasUpdateHandler","computed","isFunction","isModelBindingAbsent","doShow","value","doHide","show","disabled","shouldEmit","isClient","hide","onChange","val","isBoolean","toggle","watch","appContext","config","globalProperties","$route","proxy","onMounted","useModelToggle","useModelToggleProps","useModelToggleEmits"],"sources":["/home/bonami/Desktop/Projects/ECommerce/packages/hooks/use-model-toggle/index.ts"],"sourcesContent":["import { computed, getCurrentInstance, watch, onMounted } from 'vue'\nimport { isFunction } from '@vue/shared'\nimport { isClient } from '@vueuse/core'\nimport { isBoolean, buildProp, definePropType } from '@tw-element/utils'\nimport type { RouteLocationNormalizedLoaded } from 'vue-router'\n\nimport type { Ref, ComponentPublicInstance, ExtractPropTypes } from 'vue'\n\nexport const createModelToggleComposable = (name: string) => {\n  const useModelToggleProps = {\n    [name]: buildProp({\n      type: definePropType<boolean | null>(Boolean),\n      default: null,\n    } as const),\n    [`onUpdate:${name}`]: buildProp({\n      type: definePropType<(val: boolean) => void>(Function),\n    } as const),\n  }\n\n  const useModelToggleEmits = [`update:${name}`]\n\n  const useModelToggle = ({\n    indicator,\n    shouldHideWhenRouteChanges,\n    shouldProceed,\n    onShow,\n    onHide,\n  }: ModelToggleParams) => {\n    const instance = getCurrentInstance()!\n    const props = instance.props as UseModelToggleProps & { disabled: boolean }\n    const { emit } = instance\n\n    const updateEventKey = `update:${name}`\n\n    const hasUpdateHandler = computed(() =>\n      isFunction(props[`onUpdate:${name}`])\n    )\n    // when it matches the default value we say this is absent\n    // though this could be mistakenly passed from the user but we need to rule out that\n    // condition\n    const isModelBindingAbsent = computed(() => props[name] === null)\n\n    const doShow = () => {\n      if (indicator.value === true) {\n        return\n      }\n\n      indicator.value = true\n      if (isFunction(onShow)) {\n        onShow()\n      }\n    }\n\n    const doHide = () => {\n      if (indicator.value === false) {\n        return\n      }\n\n      indicator.value = false\n\n      if (isFunction(onHide)) {\n        onHide()\n      }\n    }\n\n    const show = () => {\n      if (\n        props.disabled === true ||\n        (isFunction(shouldProceed) && !shouldProceed())\n      )\n        return\n\n      const shouldEmit = hasUpdateHandler.value && isClient\n\n      if (shouldEmit) {\n        emit(updateEventKey, true)\n      }\n\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doShow()\n      }\n    }\n\n    const hide = () => {\n      if (props.disabled === true || !isClient) return\n\n      const shouldEmit = hasUpdateHandler.value && isClient\n\n      if (shouldEmit) {\n        emit(updateEventKey, false)\n      }\n\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doHide()\n      }\n    }\n\n    const onChange = (val: boolean) => {\n      if (!isBoolean(val)) return\n      if (props.disabled && val) {\n        if (hasUpdateHandler.value) {\n          emit(updateEventKey, false)\n        }\n      } else if (indicator.value !== val) {\n        if (val) {\n          doShow()\n        } else {\n          doHide()\n        }\n      }\n    }\n\n    const toggle = () => {\n      if (indicator.value) {\n        hide()\n      } else {\n        show()\n      }\n    }\n\n    watch(() => props[name], onChange as any)\n\n    if (\n      shouldHideWhenRouteChanges &&\n      instance.appContext.config.globalProperties.$route !== undefined\n    ) {\n      watch(\n        () => ({\n          ...(\n            instance.proxy as ComponentPublicInstance<{\n              $route: RouteLocationNormalizedLoaded\n            }>\n          ).$route,\n        }),\n        () => {\n          if (shouldHideWhenRouteChanges.value && indicator.value) {\n            hide()\n          }\n        }\n      )\n    }\n\n    onMounted(() => {\n      onChange(props[name] as boolean)\n    })\n\n    return {\n      hide,\n      show,\n      toggle,\n    }\n  }\n\n  return {\n    useModelToggle,\n    useModelToggleProps,\n    useModelToggleEmits,\n  }\n}\n\nconst { useModelToggle, useModelToggleProps, useModelToggleEmits } =\n  createModelToggleComposable('modelValue')\n\nexport { useModelToggle, useModelToggleEmits, useModelToggleProps }\n\nexport type UseModelToggleProps = ExtractPropTypes<typeof useModelToggleProps>\n\nexport type ModelToggleParams = {\n  indicator: Ref<boolean>\n  shouldHideWhenRouteChanges?: Ref<boolean>\n  shouldProceed?: () => boolean\n  onShow?: () => void\n  onHide?: () => void\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}