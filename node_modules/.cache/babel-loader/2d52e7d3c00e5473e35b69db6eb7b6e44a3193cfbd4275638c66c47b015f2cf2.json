{"ast":null,"code":"import { defineComponent, ref, provide, unref, onMounted, watch, onBeforeUnmount, renderSlot } from 'vue';\nimport '../../../utils/index.mjs';\nimport '../../../constants/index.mjs';\nimport { getEdges, tryFocus, focusableStack, focusFirstDescendant, obtainAllFocusableElements } from './utils.mjs';\nimport { ON_MOUNT_FOCUS_EVT, ON_UNMOUNT_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_ON_MOUNT, FOCUS_ON_MOUNT_OPTS, FOCUS_ON_UNMOUNT } from './tokens.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { on, off } from '../../../utils/dom/event.mjs';\nconst _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean\n  },\n  emits: [ON_MOUNT_FOCUS_EVT, ON_UNMOUNT_FOCUS_EVT],\n  setup(props, {\n    emit\n  }) {\n    const focusTrapRef = ref();\n    const forwardRef = ref(null);\n    let lastFocusBeforeMounted;\n    let lastFocusAfterMounted;\n    const focusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true;\n      },\n      resume() {\n        this.paused = false;\n      }\n    };\n    const onKeydown = e => {\n      if (!props.loop && !props.trapped) return;\n      if (focusLayer.paused) return;\n      const {\n        key,\n        altKey,\n        ctrlKey,\n        metaKey,\n        currentTarget,\n        shiftKey\n      } = e;\n      const {\n        loop\n      } = props;\n      const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      const currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget;\n        const [first, last] = getEdges(container);\n        const isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) e.preventDefault();\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault();\n            if (loop) tryFocus(first, true);\n          } else if (shiftKey && currentFocusingEl === first) {\n            e.preventDefault();\n            if (loop) tryFocus(last, true);\n          }\n        }\n      }\n    };\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown\n    });\n    const focusOnMount = e => {\n      emit(ON_MOUNT_FOCUS_EVT, e);\n    };\n    const focusOnUnmount = e => emit(ON_UNMOUNT_FOCUS_EVT, e);\n    const onFocusIn = e => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      const target = e.target;\n      if (target && trapContainer.contains(target)) {\n        lastFocusAfterMounted = target;\n      } else {\n        tryFocus(lastFocusAfterMounted, true);\n      }\n    };\n    const onFocusOut = e => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      if (!trapContainer.contains(e.relatedTarget)) {\n        tryFocus(lastFocusAfterMounted, true);\n      }\n    };\n    onMounted(() => {\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        focusableStack.push(focusLayer);\n        const prevFocusedElement = document.activeElement;\n        lastFocusBeforeMounted = prevFocusedElement;\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n        if (!isPrevFocusContained) {\n          const mountEvent = new Event(FOCUS_ON_MOUNT, FOCUS_ON_MOUNT_OPTS);\n          on(trapContainer, FOCUS_ON_MOUNT, focusOnMount);\n          trapContainer.dispatchEvent(mountEvent);\n          if (!mountEvent.defaultPrevented) {\n            focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);\n            if (document.activeElement === prevFocusedElement) {\n              tryFocus(trapContainer);\n            }\n          }\n        }\n      }\n      watch(() => props.trapped, trapped => {\n        if (trapped) {\n          on(document, \"focusin\", onFocusIn);\n          on(document, \"focusout\", onFocusOut);\n        } else {\n          off(document, \"focusin\", onFocusIn);\n          off(document, \"focusout\", onFocusOut);\n        }\n      }, {\n        immediate: true\n      });\n    });\n    onBeforeUnmount(() => {\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        off(trapContainer, FOCUS_ON_MOUNT, focusOnMount);\n        const unmountEvent = new Event(FOCUS_ON_UNMOUNT, FOCUS_ON_MOUNT_OPTS);\n        on(trapContainer, FOCUS_ON_UNMOUNT, focusOnUnmount);\n        trapContainer.dispatchEvent(unmountEvent);\n        if (!unmountEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeMounted != null ? lastFocusBeforeMounted : document.body, true);\n        }\n        off(trapContainer, FOCUS_ON_UNMOUNT, focusOnUnmount);\n        focusableStack.remove(focusLayer);\n      }\n    });\n    return {\n      focusTrapRef,\n      forwardRef,\n      onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\");\n}\nvar ElFocusTrap = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\nexport { ElFocusTrap as default };","map":{"version":3,"names":["_sfc_main","defineComponent","name","inheritAttrs","props","loop","Boolean","trapped","emits","ON_MOUNT_FOCUS_EVT","ON_UNMOUNT_FOCUS_EVT","setup","emit","focusTrapRef","ref","forwardRef","lastFocusBeforeMounted","lastFocusAfterMounted","focusLayer","paused","pause","resume","onKeydown","e","key","altKey","ctrlKey","metaKey","currentTarget","shiftKey","isTabbing","EVENT_CODE","tab","currentFocusingEl","document","activeElement","container","first","last","getEdges","isTabbable","preventDefault","tryFocus","provide","FOCUS_TRAP_INJECTION_KEY","focusOnMount","focusOnUnmount","onFocusIn","trapContainer","unref","target","contains","onFocusOut","relatedTarget","onMounted","focusableStack","push","prevFocusedElement","isPrevFocusContained","mountEvent","Event","FOCUS_ON_MOUNT","FOCUS_ON_MOUNT_OPTS","on","dispatchEvent","defaultPrevented","focusFirstDescendant","obtainAllFocusableElements","watch","off","immediate","onBeforeUnmount","unmountEvent","FOCUS_ON_UNMOUNT","body","remove","_ctx","_cache","$props","$setup","$data","$options"],"sources":["/home/bonami/Desktop/Projects/ECommerce/packages/components/focus-trap/src/focus-trap.vue"],"sourcesContent":["<template>\n  <slot />\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  ref,\n  onMounted,\n  onBeforeUnmount,\n  provide,\n  unref,\n  watch,\n} from 'vue'\nimport { on, off } from '@tw-element/utils'\nimport { EVENT_CODE } from '@tw-element/constants'\nimport {\n  focusableStack,\n  focusFirstDescendant,\n  getEdges,\n  tryFocus,\n  obtainAllFocusableElements,\n} from './utils'\nimport {\n  FOCUS_TRAP_INJECTION_KEY,\n  FOCUS_ON_MOUNT,\n  FOCUS_ON_MOUNT_OPTS,\n  ON_MOUNT_FOCUS_EVT,\n  ON_UNMOUNT_FOCUS_EVT,\n  FOCUS_ON_UNMOUNT,\n} from './tokens'\n\nimport type { FocusLayer } from './utils'\n\nexport default defineComponent({\n  name: 'ElFocusTrap',\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n  },\n  emits: [ON_MOUNT_FOCUS_EVT, ON_UNMOUNT_FOCUS_EVT],\n  setup(props, { emit }) {\n    const focusTrapRef = ref<HTMLElement | null>()\n    const forwardRef = ref<HTMLElement | null>(null)\n    let lastFocusBeforeMounted: HTMLElement | null\n    let lastFocusAfterMounted: HTMLElement | null\n\n    const focusLayer: FocusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true\n      },\n      resume() {\n        this.paused = false\n      },\n    }\n\n    const onKeydown = (e: KeyboardEvent) => {\n      if (!props.loop && !props.trapped) return\n      if (focusLayer.paused) return\n\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e\n      const { loop } = props\n      const isTabbing =\n        key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey\n\n      const currentFocusingEl = document.activeElement\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget as HTMLElement\n        const [first, last] = getEdges(container)\n        const isTabbable = first && last\n\n        if (!isTabbable) {\n          if (currentFocusingEl === container) e.preventDefault()\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault()\n            if (loop) tryFocus(first, true)\n          } else if (shiftKey && currentFocusingEl === first) {\n            e.preventDefault()\n            if (loop) tryFocus(last, true)\n          }\n        }\n      }\n    }\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown,\n    })\n\n    const focusOnMount = (e: Event) => {\n      emit(ON_MOUNT_FOCUS_EVT, e)\n    }\n    const focusOnUnmount = (e: Event) => emit(ON_UNMOUNT_FOCUS_EVT, e)\n    const onFocusIn = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n      const target = e.target as HTMLElement | null\n      if (target && trapContainer.contains(target)) {\n        lastFocusAfterMounted = target\n      } else {\n        tryFocus(lastFocusAfterMounted, true)\n      }\n    }\n\n    const onFocusOut = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n\n      if (\n        !trapContainer.contains(\n          (e as FocusEvent).relatedTarget as HTMLElement | null\n        )\n      ) {\n        tryFocus(lastFocusAfterMounted, true)\n      }\n    }\n\n    onMounted(() => {\n      const trapContainer = unref(forwardRef)\n      if (trapContainer) {\n        focusableStack.push(focusLayer)\n        const prevFocusedElement = document.activeElement\n        lastFocusBeforeMounted = prevFocusedElement as HTMLElement | null\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement)\n        if (!isPrevFocusContained) {\n          const mountEvent = new Event(FOCUS_ON_MOUNT, FOCUS_ON_MOUNT_OPTS)\n          on(trapContainer, FOCUS_ON_MOUNT, focusOnMount)\n          trapContainer.dispatchEvent(mountEvent)\n          if (!mountEvent.defaultPrevented) {\n            focusFirstDescendant(\n              obtainAllFocusableElements(trapContainer),\n              true\n            )\n            if (document.activeElement === prevFocusedElement) {\n              tryFocus(trapContainer)\n            }\n          }\n        }\n      }\n\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            on(document, 'focusin', onFocusIn)\n            on(document, 'focusout', onFocusOut)\n          } else {\n            off(document, 'focusin', onFocusIn)\n            off(document, 'focusout', onFocusOut)\n          }\n        },\n        { immediate: true }\n      )\n    })\n\n    onBeforeUnmount(() => {\n      const trapContainer = unref(forwardRef)\n\n      if (trapContainer) {\n        off(trapContainer, FOCUS_ON_MOUNT, focusOnMount)\n        const unmountEvent = new Event(FOCUS_ON_UNMOUNT, FOCUS_ON_MOUNT_OPTS)\n\n        on(trapContainer, FOCUS_ON_UNMOUNT, focusOnUnmount)\n        trapContainer.dispatchEvent(unmountEvent)\n\n        if (!unmountEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeMounted ?? document.body, true)\n        }\n\n        off(trapContainer, FOCUS_ON_UNMOUNT, focusOnUnmount)\n\n        focusableStack.remove(focusLayer)\n      }\n    })\n\n    return {\n      focusTrapRef,\n      forwardRef,\n      onKeydown,\n    }\n  },\n})\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}