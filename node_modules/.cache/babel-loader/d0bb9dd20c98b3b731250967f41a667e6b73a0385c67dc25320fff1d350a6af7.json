{"ast":null,"code":"import '../../../../utils/index.mjs';\nimport { isFF } from '../utils.mjs';\nimport { cAF, rAF } from '../../../../utils/raf.mjs';\nconst useGridWheel = ({\n  atXEndEdge,\n  atXStartEdge,\n  atYEndEdge,\n  atYStartEdge\n}, onWheelDelta) => {\n  let frameHandle = null;\n  let xOffset = 0;\n  let yOffset = 0;\n  const hasReachedEdge = (x, y) => {\n    const xEdgeReached = x < 0 && atXStartEdge.value || x > 0 && atXEndEdge.value;\n    const yEdgeReached = y < 0 && atYStartEdge.value || y > 0 && atYEndEdge.value;\n    return xEdgeReached && yEdgeReached;\n  };\n  const onWheel = e => {\n    cAF(frameHandle);\n    const x = e.deltaX;\n    const y = e.deltaY;\n    if (hasReachedEdge(xOffset, yOffset) && hasReachedEdge(xOffset + x, yOffset + y)) return;\n    xOffset += x;\n    yOffset += y;\n    if (!isFF) {\n      e.preventDefault();\n    }\n    frameHandle = rAF(() => {\n      onWheelDelta(xOffset, yOffset);\n      xOffset = 0;\n      yOffset = 0;\n    });\n  };\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\nexport { useGridWheel };","map":{"version":3,"names":["useGridWheel","atXEndEdge","atXStartEdge","atYEndEdge","atYStartEdge","onWheelDelta","frameHandle","xOffset","yOffset","hasReachedEdge","x","y","xEdgeReached","value","yEdgeReached","onWheel","e","cAF","deltaX","deltaY","isFF","preventDefault","rAF"],"sources":["/home/bonami/Desktop/Projects/ECommerce/packages/components/virtual-list/src/hooks/use-grid-wheel.ts"],"sourcesContent":["import { rAF, cAF } from '@tw-element/utils'\nimport { isFF } from '../utils'\n\nimport type { ComputedRef } from 'vue'\n\ninterface GridWheelState {\n  atXStartEdge: ComputedRef<boolean>\n  atXEndEdge: ComputedRef<boolean>\n  atYStartEdge: ComputedRef<boolean>\n  atYEndEdge: ComputedRef<boolean>\n}\n\ntype GridWheelHandler = (x: number, y: number) => void\n\nexport const useGridWheel = (\n  { atXEndEdge, atXStartEdge, atYEndEdge, atYStartEdge }: GridWheelState,\n  onWheelDelta: GridWheelHandler\n) => {\n  let frameHandle: number | null = null\n  let xOffset = 0\n  let yOffset = 0\n\n  const hasReachedEdge = (x: number, y: number) => {\n    const xEdgeReached =\n      (x < 0 && atXStartEdge.value) || (x > 0 && atXEndEdge.value)\n    const yEdgeReached =\n      (y < 0 && atYStartEdge.value) || (y > 0 && atYEndEdge.value)\n    return xEdgeReached && yEdgeReached\n  }\n\n  const onWheel = (e: WheelEvent) => {\n    cAF(frameHandle!)\n\n    const x = e.deltaX\n    const y = e.deltaY\n\n    if (\n      hasReachedEdge(xOffset, yOffset) &&\n      hasReachedEdge(xOffset + x, yOffset + y)\n    )\n      return\n\n    xOffset += x\n    yOffset += y\n\n    if (!isFF) {\n      e.preventDefault()\n    }\n\n    frameHandle = rAF(() => {\n      onWheelDelta(xOffset, yOffset)\n      xOffset = 0\n      yOffset = 0\n    })\n  }\n\n  return {\n    hasReachedEdge,\n    onWheel,\n  }\n}\n"],"mappings":";;;AAEY,MAACA,YAAY,GAAGA,CAAC;EAAEC,UAAU;EAAEC,YAAY;EAAEC,UAAU;EAAEC;AAAY,CAAE,EAAEC,YAAY,KAAK;EACpG,IAAIC,WAAW,GAAG,IAAI;EACtB,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,OAAO,GAAG,CAAC;EACf,MAAMC,cAAc,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;IAC/B,MAAMC,YAAY,GAAGF,CAAC,GAAG,CAAC,IAAIR,YAAY,CAACW,KAAK,IAAIH,CAAC,GAAG,CAAC,IAAIT,UAAU,CAACY,KAAK;IAC7E,MAAMC,YAAY,GAAGH,CAAC,GAAG,CAAC,IAAIP,YAAY,CAACS,KAAK,IAAIF,CAAC,GAAG,CAAC,IAAIR,UAAU,CAACU,KAAK;IAC7E,OAAOD,YAAY,IAAIE,YAAY;EACvC,CAAG;EACD,MAAMC,OAAO,GAAIC,CAAC,IAAK;IACrBC,GAAG,CAACX,WAAW,CAAC;IAChB,MAAMI,CAAC,GAAGM,CAAC,CAACE,MAAM;IAClB,MAAMP,CAAC,GAAGK,CAAC,CAACG,MAAM;IAClB,IAAIV,cAAc,CAACF,OAAO,EAAEC,OAAO,CAAC,IAAIC,cAAc,CAACF,OAAO,GAAGG,CAAC,EAAEF,OAAO,GAAGG,CAAC,CAAC,EAC9E;IACFJ,OAAO,IAAIG,CAAC;IACZF,OAAO,IAAIG,CAAC;IACZ,IAAI,CAACS,IAAI,EAAE;MACTJ,CAAC,CAACK,cAAc,EAAE;IACxB;IACIf,WAAW,GAAGgB,GAAG,CAAC,MAAM;MACtBjB,YAAY,CAACE,OAAO,EAAEC,OAAO,CAAC;MAC9BD,OAAO,GAAG,CAAC;MACXC,OAAO,GAAG,CAAC;IACjB,CAAK,CAAC;EACN,CAAG;EACD,OAAO;IACLC,cAAc;IACdM;EACJ,CAAG;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}