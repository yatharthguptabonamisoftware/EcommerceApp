{"ast":null,"code":"import { defineComponent, shallowRef, reactive, computed, watch, onMounted, openBlock, createElementBlock, normalizeClass, normalizeStyle, createElementVNode, renderSlot } from 'vue';\nimport { useEventListener, useResizeObserver } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { affixProps, affixEmits } from './affix.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { getScrollContainer } from '../../../utils/dom/scroll.mjs';\nconst _sfc_main = defineComponent({\n  name: \"TwAffix\",\n  props: affixProps,\n  emits: affixEmits,\n  setup(props, {\n    emit\n  }) {\n    const ns = useNamespace(\"affix\");\n    const target = shallowRef();\n    const root = shallowRef();\n    const scrollContainer = shallowRef();\n    const state = reactive({\n      fixed: false,\n      height: 0,\n      width: 0,\n      scrollTop: 0,\n      clientHeight: 0,\n      transform: 0\n    });\n    const rootStyle = computed(() => {\n      return {\n        height: state.fixed ? `${state.height}px` : \"\",\n        width: state.fixed ? `${state.width}px` : \"\"\n      };\n    });\n    const affixStyle = computed(() => {\n      if (!state.fixed) return;\n      const offset = props.offset ? `${props.offset}px` : 0;\n      const transform = state.transform ? `translateY(${state.transform}px)` : \"\";\n      return {\n        height: `${state.height}px`,\n        width: `${state.width}px`,\n        top: props.position === \"top\" ? offset : \"\",\n        bottom: props.position === \"bottom\" ? offset : \"\",\n        transform,\n        zIndex: props.zIndex\n      };\n    });\n    const update = () => {\n      if (!root.value || !target.value || !scrollContainer.value) return;\n      const rootRect = root.value.getBoundingClientRect();\n      const targetRect = target.value.getBoundingClientRect();\n      state.height = rootRect.height;\n      state.width = rootRect.width;\n      state.scrollTop = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop || 0;\n      state.clientHeight = document.documentElement.clientHeight;\n      if (props.position === \"top\") {\n        if (props.target) {\n          const difference = targetRect.bottom - props.offset - state.height;\n          state.fixed = props.offset > rootRect.top && targetRect.bottom > 0;\n          state.transform = difference < 0 ? difference : 0;\n        } else {\n          state.fixed = props.offset > rootRect.top;\n        }\n      } else {\n        if (props.target) {\n          const difference = state.clientHeight - targetRect.top - props.offset - state.height;\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom && state.clientHeight > targetRect.top;\n          state.transform = difference < 0 ? -difference : 0;\n        } else {\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom;\n        }\n      }\n    };\n    const onScroll = () => {\n      update();\n      emit(\"scroll\", {\n        scrollTop: state.scrollTop,\n        fixed: state.fixed\n      });\n    };\n    watch(() => state.fixed, () => {\n      emit(\"change\", state.fixed);\n    });\n    onMounted(() => {\n      var _a;\n      if (props.target) {\n        target.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;\n        if (!target.value) {\n          throw new Error(`Target is not existed: ${props.target}`);\n        }\n      } else {\n        target.value = document.documentElement;\n      }\n      scrollContainer.value = getScrollContainer(root.value, true);\n    });\n    useEventListener(scrollContainer, \"scroll\", onScroll);\n    useResizeObserver(root, () => update());\n    useResizeObserver(target, () => update());\n    return {\n      ns,\n      root,\n      state,\n      rootStyle,\n      affixStyle,\n      update\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", {\n    ref: \"root\",\n    class: normalizeClass(_ctx.ns.b()),\n    style: normalizeStyle(_ctx.rootStyle)\n  }, [createElementVNode(\"div\", {\n    class: normalizeClass({\n      [_ctx.ns.m(\"fixed\")]: _ctx.state.fixed\n    }),\n    style: normalizeStyle(_ctx.affixStyle)\n  }, [renderSlot(_ctx.$slots, \"default\")], 6)], 6);\n}\nvar Affix = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\nexport { Affix as default };","map":{"version":3,"names":["_sfc_main","defineComponent","name","props","affixProps","emits","affixEmits","setup","emit","ns","useNamespace","target","shallowRef","root","scrollContainer","state","reactive","fixed","height","width","scrollTop","clientHeight","transform","rootStyle","computed","affixStyle","offset","top","position","bottom","zIndex","update","value","rootRect","getBoundingClientRect","targetRect","Window","document","documentElement","difference","onScroll","watch","onMounted","_a","querySelector","Error","getScrollContainer","useEventListener","useResizeObserver","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","openBlock","createElementBlock","ref","class","normalizeClass","b","createElementVNode","m"],"sources":["/home/bonami/Desktop/Projects/ECommerce/packages/components/affix/src/affix.vue"],"sourcesContent":["<template>\n  <div ref=\"root\" :class=\"ns.b()\" :style=\"rootStyle\">\n    <div :class=\"{ [ns.m('fixed')]: state.fixed }\" :style=\"affixStyle\">\n      <slot></slot>\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  onMounted,\n  reactive,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { useEventListener, useResizeObserver } from '@vueuse/core'\nimport { getScrollContainer } from '@tw-element/utils'\nimport { useNamespace } from '@tw-element/hooks'\nimport { affixEmits, affixProps } from './affix'\n\nimport type { CSSProperties } from 'vue'\n\nexport default defineComponent({\n  name: 'TwAffix',\n\n  props: affixProps,\n  emits: affixEmits,\n\n  setup(props, { emit }) {\n    const ns = useNamespace('affix')\n\n    const target = shallowRef<HTMLElement>()\n    const root = shallowRef<HTMLDivElement>()\n    const scrollContainer = shallowRef<HTMLElement | Window>()\n\n    const state = reactive({\n      fixed: false,\n      height: 0, // height of root\n      width: 0, // width of root\n      scrollTop: 0, // scrollTop of documentElement\n      clientHeight: 0, // clientHeight of documentElement\n      transform: 0,\n    })\n\n    const rootStyle = computed<CSSProperties>(() => {\n      return {\n        height: state.fixed ? `${state.height}px` : '',\n        width: state.fixed ? `${state.width}px` : '',\n      }\n    })\n\n    const affixStyle = computed<CSSProperties | undefined>(() => {\n      if (!state.fixed) return\n\n      const offset = props.offset ? `${props.offset}px` : 0\n      const transform = state.transform\n        ? `translateY(${state.transform}px)`\n        : ''\n\n      return {\n        height: `${state.height}px`,\n        width: `${state.width}px`,\n        top: props.position === 'top' ? offset : '',\n        bottom: props.position === 'bottom' ? offset : '',\n        transform,\n        zIndex: props.zIndex,\n      }\n    })\n\n    const update = () => {\n      if (!root.value || !target.value || !scrollContainer.value) return\n\n      const rootRect = root.value.getBoundingClientRect()\n      const targetRect = target.value.getBoundingClientRect()\n      state.height = rootRect.height\n      state.width = rootRect.width\n      state.scrollTop =\n        scrollContainer.value instanceof Window\n          ? document.documentElement.scrollTop\n          : scrollContainer.value.scrollTop || 0\n      state.clientHeight = document.documentElement.clientHeight\n\n      if (props.position === 'top') {\n        if (props.target) {\n          const difference = targetRect.bottom - props.offset - state.height\n          state.fixed = props.offset > rootRect.top && targetRect.bottom > 0\n          state.transform = difference < 0 ? difference : 0\n        } else {\n          state.fixed = props.offset > rootRect.top\n        }\n      } else {\n        if (props.target) {\n          const difference =\n            state.clientHeight - targetRect.top - props.offset - state.height\n          state.fixed =\n            state.clientHeight - props.offset < rootRect.bottom &&\n            state.clientHeight > targetRect.top\n          state.transform = difference < 0 ? -difference : 0\n        } else {\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom\n        }\n      }\n    }\n\n    const onScroll = () => {\n      update()\n\n      emit('scroll', {\n        scrollTop: state.scrollTop,\n        fixed: state.fixed,\n      })\n    }\n\n    watch(\n      () => state.fixed,\n      () => {\n        emit('change', state.fixed)\n      }\n    )\n\n    onMounted(() => {\n      if (props.target) {\n        target.value =\n          document.querySelector<HTMLElement>(props.target) ?? undefined\n        if (!target.value) {\n          throw new Error(`Target is not existed: ${props.target}`)\n        }\n      } else {\n        target.value = document.documentElement\n      }\n      scrollContainer.value = getScrollContainer(root.value!, true)\n    })\n\n    useEventListener(scrollContainer, 'scroll', onScroll)\n    useResizeObserver(root, () => update())\n    useResizeObserver(target, () => update())\n\n    return {\n      ns,\n      root,\n      state,\n      rootStyle,\n      affixStyle,\n      update,\n    }\n  },\n})\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}