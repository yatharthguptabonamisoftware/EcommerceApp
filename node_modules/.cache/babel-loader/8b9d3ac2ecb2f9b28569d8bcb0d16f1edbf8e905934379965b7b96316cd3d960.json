{"ast":null,"code":"import { ref, getCurrentInstance, watch, nextTick } from 'vue';\nimport { SetOperationEnum, NODE_CHECK, NODE_CHECK_CHANGE } from '../virtual-tree.mjs';\nfunction useCheck(props, tree) {\n  const checkedKeys = ref( /* @__PURE__ */new Set());\n  const indeterminateKeys = ref( /* @__PURE__ */new Set());\n  const {\n    emit\n  } = getCurrentInstance();\n  watch(() => tree.value, () => {\n    return nextTick(() => {\n      _setCheckedKeys(props.defaultCheckedKeys);\n    });\n  }, {\n    immediate: true\n  });\n  const updateCheckedKeys = () => {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return;\n    }\n    const {\n      levTwTreeNodeMap,\n      maxLevel\n    } = tree.value;\n    const checkedKeySet = checkedKeys.value;\n    const indeterminateKeySet = /* @__PURE__ */new Set();\n    for (let level = maxLevel - 1; level >= 1; --level) {\n      const nodes = levTwTreeNodeMap.get(level);\n      if (!nodes) continue;\n      nodes.forEach(node => {\n        const children = node.children;\n        if (children) {\n          let allChecked = true;\n          let hasChecked = false;\n          for (let i = 0; i < children.length; ++i) {\n            const childNode = children[i];\n            const key = childNode.key;\n            if (checkedKeySet.has(key)) {\n              hasChecked = true;\n            } else if (indeterminateKeySet.has(key)) {\n              allChecked = false;\n              hasChecked = true;\n              break;\n            } else {\n              allChecked = false;\n            }\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key);\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key);\n            checkedKeySet.delete(node.key);\n          } else {\n            checkedKeySet.delete(node.key);\n            indeterminateKeySet.delete(node.key);\n          }\n        }\n      });\n    }\n    indeterminateKeys.value = indeterminateKeySet;\n  };\n  const isChecked = node => checkedKeys.value.has(node.key);\n  const isIndeterminate = node => indeterminateKeys.value.has(node.key);\n  const toggleCheckbox = (node, isChecked2, nodeClick = true) => {\n    const checkedKeySet = checkedKeys.value;\n    const toggle = (node2, checked) => {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);\n      const children = node2.children;\n      if (!props.checkStrictly && children) {\n        children.forEach(childNode => {\n          if (!childNode.disabled) {\n            toggle(childNode, checked);\n          }\n        });\n      }\n    };\n    toggle(node, isChecked2);\n    updateCheckedKeys();\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked2);\n    }\n  };\n  const afterNodeCheck = (node, checked) => {\n    const {\n      checkedNodes,\n      checkedKeys: checkedKeys2\n    } = getChecked();\n    const {\n      halfCheckedNodes,\n      halfCheckedKeys\n    } = getHalfChecked();\n    emit(NODE_CHECK, node.data, {\n      checkedKeys: checkedKeys2,\n      checkedNodes,\n      halfCheckedKeys,\n      halfCheckedNodes\n    });\n    emit(NODE_CHECK_CHANGE, node.data, checked);\n  };\n  function getCheckedKeys(leafOnly = false) {\n    return getChecked(leafOnly).checkedKeys;\n  }\n  function getCheckedNodes(leafOnly = false) {\n    return getChecked(leafOnly).checkedNodes;\n  }\n  function getHalfCheckedKeys() {\n    return getHalfChecked().halfCheckedKeys;\n  }\n  function getHalfCheckedNodes() {\n    return getHalfChecked().halfCheckedNodes;\n  }\n  function getChecked(leafOnly = false) {\n    const checkedNodes = [];\n    const keys = [];\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      checkedKeys.value.forEach(key => {\n        const node = treeNodeMap.get(key);\n        if (node && (!leafOnly || leafOnly && node.isLeaf)) {\n          keys.push(key);\n          checkedNodes.push(node.data);\n        }\n      });\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes\n    };\n  }\n  function getHalfChecked() {\n    const halfCheckedNodes = [];\n    const halfCheckedKeys = [];\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      indeterminateKeys.value.forEach(key => {\n        const node = treeNodeMap.get(key);\n        if (node) {\n          halfCheckedKeys.push(key);\n          halfCheckedNodes.push(node.data);\n        }\n      });\n    }\n    return {\n      halfCheckedNodes,\n      halfCheckedKeys\n    };\n  }\n  function setCheckedKeys(keys) {\n    checkedKeys.value.clear();\n    _setCheckedKeys(keys);\n  }\n  function setChecked(key, isChecked2) {\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      const node = tree.value.treeNodeMap.get(key);\n      if (node) {\n        toggleCheckbox(node, isChecked2, false);\n      }\n    }\n  }\n  function _setCheckedKeys(keys) {\n    if (tree == null ? void 0 : tree.value) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      if (props.showCheckbox && treeNodeMap && keys) {\n        for (let i = 0; i < keys.length; ++i) {\n          const key = keys[i];\n          const node = treeNodeMap.get(key);\n          if (node && !isChecked(node)) {\n            toggleCheckbox(node, true, false);\n          }\n        }\n      }\n    }\n  }\n  return {\n    updateCheckedKeys,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys\n  };\n}\nexport { useCheck };","map":{"version":3,"names":["useCheck","props","tree","checkedKeys","ref","Set","indeterminateKeys","emit","getCurrentInstance","watch","value","nextTick","_setCheckedKeys","defaultCheckedKeys","immediate","updateCheckedKeys","showCheckbox","checkStrictly","levTwTreeNodeMap","maxLevel","checkedKeySet","indeterminateKeySet","level","nodes","get","forEach","node","children","allChecked","hasChecked","i","length","childNode","key","has","add","delete","isChecked","isIndeterminate","toggleCheckbox","isChecked2","nodeClick","toggle","node2","checked","SetOperationEnum","ADD","DELETE","disabled","afterNodeCheck","checkedNodes","checkedKeys2","getChecked","halfCheckedNodes","halfCheckedKeys","getHalfChecked","NODE_CHECK","data","NODE_CHECK_CHANGE","getCheckedKeys","leafOnly","getCheckedNodes","getHalfCheckedKeys","getHalfCheckedNodes","keys","treeNodeMap","isLeaf","push","setCheckedKeys","clear","setChecked"],"sources":["/home/bonami/Desktop/Projects/ECommerce/packages/components/tree-v2/src/composables/useCheck.ts"],"sourcesContent":["import { nextTick, ref, watch, getCurrentInstance } from 'vue'\nimport {\n  NODE_CHECK_CHANGE,\n  NODE_CHECK,\n  SetOperationEnum,\n} from '../virtual-tree'\nimport type { Ref } from 'vue'\nimport type { TreeProps, TreeKey, TreeNode, Tree, TreeNodeData } from '../types'\n\nexport function useCheck(props: TreeProps, tree: Ref<Tree | undefined>) {\n  const checkedKeys = ref<Set<TreeKey>>(new Set())\n  const indeterminateKeys = ref<Set<TreeKey>>(new Set())\n  const { emit } = getCurrentInstance()!\n\n  watch(\n    () => tree.value,\n    () => {\n      return nextTick(() => {\n        _setCheckedKeys(props.defaultCheckedKeys)\n      })\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  const updateCheckedKeys = () => {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return\n    }\n    const { levTwTreeNodeMap, maxLevel } = tree.value\n    const checkedKeySet = checkedKeys.value\n    const indeterminateKeySet = new Set<TreeKey>()\n    // It is easier to determine the indeterminate state by\n    // traversing from bottom to top\n    // leaf nodes not have indeterminate status and can be skipped\n    for (let level = maxLevel - 1; level >= 1; --level) {\n      const nodes = levTwTreeNodeMap.get(level)\n      if (!nodes) continue\n      nodes.forEach((node) => {\n        const children = node.children\n        if (children) {\n          // Whether all child nodes are selected\n          let allChecked = true\n          // Whether a child node is selected\n          let hasChecked = false\n          for (let i = 0; i < children.length; ++i) {\n            const childNode = children[i]\n            const key = childNode.key\n            if (checkedKeySet.has(key)) {\n              hasChecked = true\n            } else if (indeterminateKeySet.has(key)) {\n              allChecked = false\n              hasChecked = true\n              break\n            } else {\n              allChecked = false\n            }\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key)\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key)\n            checkedKeySet.delete(node.key)\n          } else {\n            checkedKeySet.delete(node.key)\n            indeterminateKeySet.delete(node.key)\n          }\n        }\n      })\n    }\n    indeterminateKeys.value = indeterminateKeySet\n  }\n\n  const isChecked = (node: TreeNode) => checkedKeys.value.has(node.key)\n\n  const isIndeterminate = (node: TreeNode) =>\n    indeterminateKeys.value.has(node.key)\n\n  const toggleCheckbox = (\n    node: TreeNode,\n    isChecked: boolean,\n    nodeClick = true\n  ) => {\n    const checkedKeySet = checkedKeys.value\n    const toggle = (node: TreeNode, checked: boolean) => {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](\n        node.key\n      )\n      const children = node.children\n      if (!props.checkStrictly && children) {\n        children.forEach((childNode) => {\n          if (!childNode.disabled) {\n            toggle(childNode, checked)\n          }\n        })\n      }\n    }\n    toggle(node, isChecked)\n    updateCheckedKeys()\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked)\n    }\n  }\n\n  const afterNodeCheck = (node: TreeNode, checked: boolean) => {\n    const { checkedNodes, checkedKeys } = getChecked()\n    const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked()\n    emit(NODE_CHECK, node.data, {\n      checkedKeys,\n      checkedNodes,\n      halfCheckedKeys,\n      halfCheckedNodes,\n    })\n    emit(NODE_CHECK_CHANGE, node.data, checked)\n  }\n\n  // expose\n  function getCheckedKeys(leafOnly = false): TreeKey[] {\n    return getChecked(leafOnly).checkedKeys\n  }\n\n  function getCheckedNodes(leafOnly = false): TreeNodeData[] {\n    return getChecked(leafOnly).checkedNodes\n  }\n\n  function getHalfCheckedKeys(): TreeKey[] {\n    return getHalfChecked().halfCheckedKeys\n  }\n\n  function getHalfCheckedNodes(): TreeNodeData[] {\n    return getHalfChecked().halfCheckedNodes\n  }\n\n  function getChecked(leafOnly = false): {\n    checkedKeys: TreeKey[]\n    checkedNodes: TreeNodeData[]\n  } {\n    const checkedNodes: TreeNodeData[] = []\n    const keys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      checkedKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node && (!leafOnly || (leafOnly && node.isLeaf))) {\n          keys.push(key)\n          checkedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes,\n    }\n  }\n\n  function getHalfChecked(): {\n    halfCheckedKeys: TreeKey[]\n    halfCheckedNodes: TreeNodeData[]\n  } {\n    const halfCheckedNodes: TreeNodeData[] = []\n    const halfCheckedKeys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      indeterminateKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node) {\n          halfCheckedKeys.push(key)\n          halfCheckedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      halfCheckedNodes,\n      halfCheckedKeys,\n    }\n  }\n\n  function setCheckedKeys(keys: TreeKey[]) {\n    checkedKeys.value.clear()\n    _setCheckedKeys(keys)\n  }\n\n  function setChecked(key: TreeKey, isChecked: boolean) {\n    if (tree?.value && props.showCheckbox) {\n      const node = tree.value.treeNodeMap.get(key)\n      if (node) {\n        toggleCheckbox(node, isChecked, false)\n      }\n    }\n  }\n\n  function _setCheckedKeys(keys: TreeKey[]) {\n    if (tree?.value) {\n      const { treeNodeMap } = tree.value\n      if (props.showCheckbox && treeNodeMap && keys) {\n        for (let i = 0; i < keys.length; ++i) {\n          const key = keys[i]\n          const node = treeNodeMap.get(key)\n          if (node && !isChecked(node)) {\n            toggleCheckbox(node, true, false)\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    updateCheckedKeys,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    // expose\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}